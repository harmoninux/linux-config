diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index 94fa98108..4572e3380 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -44,6 +44,8 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/tty.h>
+#include <linux/vt_kern.h>
+#include <linux/sched/signal.h>
 #include <linux/types.h>
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
@@ -1608,6 +1610,93 @@ static void n_tty_receive_buf_standard(struct tty_struct *tty, const u8 *cp,
 	}
 }
 
+static void __do_set_pty_winsize(struct tty_struct *tty, unsigned rows, unsigned cols) {
+
+    struct winsize ws;
+    struct siginfo info;
+    struct pid* pgrp;
+
+    /* prepare winsize */
+    memset(&ws, 0, sizeof(ws));
+    ws.ws_row = rows;
+    ws.ws_col = cols;
+
+    /* set tty winsize */
+    tty_do_resize(tty, &ws);  /* or tty_port_set_winsize(tty->port, rows, cols) */
+
+    /* notify foreground process group with SIGWINCH */
+    memset(&info, 0, sizeof(info));
+    info.si_signo = SIGWINCH;
+    info.si_code  = SI_KERNEL;
+
+	pgrp = tty_get_pgrp(tty);
+    if (pgrp) {
+		kill_pgrp(pgrp, SIGWINCH, 1);
+        put_pid(pgrp);
+    }
+}
+
+static void __process_set_size(struct tty_struct *tty, const u8 *cp, size_t count) {
+
+	enum { S_NORMAL, S_ESC, S_CSI, S_PARAM } state = S_NORMAL;
+	unsigned int params[4] = { 0 };
+	int nparams = 0;
+
+	int i;
+	for (i = 0; i < count; ++i) {
+		unsigned char ch = cp[i];
+		switch (state) {
+		case S_NORMAL:
+			if (ch == 0x1b) { /* ESC */
+				state = S_ESC;
+				nparams = 0;
+			}
+			break;
+		case S_ESC:
+			if (ch == '[') {
+				state = S_CSI;
+			} else {
+				state = S_NORMAL;
+			}
+			break;
+		case S_CSI:
+			if (ch >= '0' && ch <= '9') {
+				params[0] = ch - '0';
+				nparams = 1;
+				state = S_PARAM;
+			} else {
+				/* not our sequence */
+				state = S_NORMAL;
+			}
+			break;
+		case S_PARAM:
+			if (ch >= '0' && ch <= '9') {
+				params[nparams-1] = params[nparams-1] * 10 + (ch - '0');
+			} else if (ch == ';') {
+				if (nparams < 4) {
+					params[nparams++] = 0;
+				} else {
+					state = S_NORMAL;
+				}
+			} else if (ch == 't') {
+				/* Expect that the first parameter is 8 for "CSI 8 ; r ; c t" */
+				if (nparams >= 3 && params[0] == 8) {
+					unsigned int rows = params[1];
+					unsigned int cols = params[2];
+					/* rudimentary sanity checks */
+					if (rows >= 1 && rows <= 4096 && cols >= 1 && cols <= 4096) {
+						__do_set_pty_winsize(tty, rows, cols);
+					}
+				}
+				state = S_NORMAL;
+			} else {
+				state = S_NORMAL;
+			}
+			break;
+		}
+	}
+}
+
 static void __receive_buf(struct tty_struct *tty, const u8 *cp, const u8 *fp,
 			  size_t count)
 {
@@ -1615,6 +1704,10 @@ static void __receive_buf(struct tty_struct *tty, const u8 *cp, const u8 *fp,
 	bool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));
 	size_t la_count = min(ldata->lookahead_count, count);
 
+	if(tty->driver->type == TTY_DRIVER_TYPE_SERIAL) {
+		__process_set_size(tty, cp, count);
+	}
+
 	if (ldata->real_raw)
 		n_tty_receive_buf_real_raw(tty, cp, count);
 	else if (ldata->raw || (L_EXTPROC(tty) && !preops))
